<!DOCTYPE html>
<html lang="pt-br">
<head>
	<title>trabalho git</title>
	<meta charset="utf-8" />
</head>
<body>
<h1>Gestão de configuração</h1>

<p>Nesta seção serão apresentados os processos de gestão de configuração do projeto.</p>

<h3>Responsabilidades</h3>

<span color="red">atualizar</span>

<p>A gerência de configuração é atividade exercida por três papéis, cujas responsabilidades são descritas na tabela abaixo.</p>

<p>Papel<br>
Responsabilidades<br>
Gerente de configuração ou integrador de configuração<br>
i. elaborar e ajustar este documento;<br>
i. elaborar e ajustar este documento;<br>
ii. controlar as baselines dos produtos;<br>
iii. realizar a integração (merge) junto às equipes de desenvolvimento;<br>
iv. realizar auditorias para garantir o cumprimento das atividades de gerenciamento de configuração pelas equipes de trabalho;<br>
v. informar o status da configuração;<br>
vi. definir permissões de acesso aos repositórios;<br>
vii. gerar tags;<br>
viii. gerar branchs;<br>
ix. gerar builds;<br>
x. gerar releases
desenvolvedor 	i. respeitar as definições deste documento quando da elaboração ou modificação dos artefatos afetados pela gerência de configuração (itens de configuração) a ele atribuídos;<br>
ii. realizar a integração (merge) com a gerência de configuração;<br>
iii. gerar builds a pedido da gerência de configuração;<br>
iv. gerar releases a pedido da gerência de configuração
Analista de sistema 	i. respeitar as definições deste documento quando da elaboração ou modificação dos artefatos afetados pela gerência de configuração (itens de configuração) a ele atribuídos.
</p>

<h3>Versionamento</h3>

<p>Os documentos relacionados ao projeto PJe são mantidos nesta wiki, no testlink e no Redmine. O versionamento adotado para os documentos será o disponível nas ferramentas citadas. Os códigos fontes, assim como artefatos de banco de dados, são mantidos no GIT. Seguem direcionamentos a respeito do versionamento dos artefatos.
Regras de Versionamento</p>

<p>O esquema de numeração de versões adotado pelo CNJ é baseado no esquema adotado pela organização Apache Foundation. O esquema define que uma versão é composta por quatro números inteiros, MAJOR.MINOR.MICRO.PATCH onde:
</p>

<h3>MAJOR</h3>
<p>Número principal da versão, somente alterado quando:
a)há modificação de arquitetura do sistema, ainda que não tenha havido modificação da estrutura de dados;
b)há modificação da estrutura de dados que demanda uma migração significativa de uma base para outra base de dados, não sendo suficiente a mera concretização de scripts de migração de dados entre tabelas de um mesmo banco de dados.
Esse número deve ser 0 para a versão anterior à primeira.
</p>

<h3>MINOR</h3>
<p>Número menor de versão, modificado sempre que houver inclusão de um ou mais conjuntos de novas funcionalidades. Esse número deve iniciar em 0 e deve ser reiniciado quando da troca do número principal.</p>

<h3>MICRO</h3>
<p>Número micro de versão, modificado sempre que liberada uma versão de correção de erros ou de comportamento esperado na versão do sistema. Esse número deve iniciar em 0 e deve ser reiniciado quando da troca do número intermediário ou do número principal. Para versões intermediárias ou principais novas, antes da homologação, esse número deverá ser acrescido do milestone de liberação (M1, M2, M3 etc.) até que a versão seja homologada, quando receberá o número menor.</p>

<h3>PATCH</h3>
<p>Número de correção de versão, modificado sempre que liberada uma versão de correção de erros críticos do sistema.
</p>

<p>A Figura 5.1-1 apresenta em detalhes como o processo ocorre. O repositório possui dois branches principais: o master, que recebe todas as modificações planejadas para a próxima versão, e o stable, que representa a versão atual em produção.
Quando a nova versão está prestes a ser lançada, é realizado um merge entre os branches master e stable. Neste mesmo momento, um branch para a versão atual é criado e mantido até que a nova versão estável esteja pronta para produção. Logo após o merge, inicia-se o período de estabilização da nova versão com o objetivo de corrigir eventuais bugs introduzidos pelas novas funcionalidades. Uma vez estável, uma tag é marcada e a versão está pronta para ser usada em produção e, após o lançamento da versão, inicia-se o ciclo de manutenção.
FIGURA 5.1-1
<img src="img1.jpg" width="700px" height="300px" />

    <h3>Nomes das versões do sistema</h3>

    <p>As versões intermediárias do sistema receberão o nome de município brasileiro iniciado na letra de referência da versão, estas na ordem alfabética, que não contenha espaços ou caracteres especiais, obtidos a partir do nome das unidades federativas, essas na ordem alfabética inversa. Assim, por exemplo, temos:</p>
    Versão 	Letra de referência 	Unidade Federativa 	Município existente na letra de referência<br>
    1.0 	A 	Tocantins 	Alvorada<br>
    1.1 	B 	Sergipe 	Balbinos<br>
    1.2 	C 	São Paulo 	Capela<br>
    1.4 	D 	Santa Catarina 	Descanso<br>
    2.0 	E 	Roraima 	Esmeralda<br>
    Versões de bibliotecas ou projetos utilitários do sistema<br>

<p>As bibliotecas ou projetos utilitários do sistema receberão sua numeração seguindo as seguintes regras:</p>

X.Y.Z<br><br>

<p>, onde:<br>
X &nbsp &nbsp &nbsp &nbsp Número principal da versão, a ser alterada quando:a) opcionalmente, os desenvolvedores incluíram na versão substanciais alterações que melhoram as funcionalidades existentes; b) obrigatoriamente, quando a nova versão não é compatível, em nível de interface, com a versão de produção atual. A compatibilidade em nível de interface existe quando, substituída uma versão por outra em um projeto que somente faz uso das interfaces públicas da biblioteca, não há erro de compilação. Esse número deve ser 0 para a versão anterior à primeira.<br>
Y &nbsp &nbsp &nbsp &nbsp 	Número intermediário de versão, a ser alterado quando há acréscimos de funcionalidades em relação à versão anterior e não foi mantida a compatibilidade em nível de interface. Esse número deve iniciar em 0 e reiniciado quando da troca do número principal.,<br>
Z &nbsp &nbsp &nbsp &nbsp Número menor de versão, modificado sempre que liberada versão de correção de erros ou de comportamento esperado na versão do sistema. Esse número deve iniciar em 0 e reiniciado quando da troca do número intermediário ou do número principal. Para versões intermediárias ou principais novas, antes da homologação, esse número deverá ser acrescido do milestone de liberação (M1, M2, M3 etc.) até que a versão seja homologada, quando receberá o número menor.
Versões de banco de dados
</p>

<p>Os dumps de bancos de dados seguirão a nomenclatura da versão a que estão vinculadas, acrescido de descritor de seu conteúdo, quando necessário.</p>

<H4>Exemplos:</H4>

<ul>
  <li> pjedb_1.0.1_treinamento.backup</li>
    <li>pjedb_1.0.1_treinamentobin.backup</li>
    <li>pjedb_1.0.1_limpa.backup</li>
    <li>pjedb_1.0.1_limpabin.backup</li>
    <li>pjedb_1.2.0_limpa.backup</li>
</ul>

<p>No caso de scripts de bancos de dados, deverá ser seguida a seguinte regra de nomenclatura:
<ul>
<li>pjescript_importacao_<,versaodestino,>_<,descricao>.sql</li>
<l1>pjescript_conversao_<,vorigem>-<,vdestino>_descricao.sql</l1>
</ul>
,onde a descrição é opcional.</p>

        Exemplos: • pjescript_importacao_1.0.1_cep.sql • pjescript_conversao_1.0.1-1.0.1.sql • pjescript_importacao_1.0.1_cnae.sql
        Repositórios distribuídos

        O GIT tem sido amplamente adotado em projetos de código e desenvolvimento abertos por permitir a coordenação de várias equipes de desenvolvimento de forma simples e transparente.
        A Figura 5.2-1 apresenta uma organização de repositórios distribuídos com três papéis distintos. A disposição é formada por um repositório central (CNJ Abençoado), sob responsabilidade dos líderes do projeto, e repositórios locais para cada equipe participante do desenvolvimento.
        Cada um dos repositórios locais tem uma equipe formada por desenvolvedores, revisores de código e um ou mais gestores. O processo de desenvolvimento estende fluxo definido em Fluxo de trabalho, acrescentando os seguintes passos:

        Os desenvolvedores resolvem issues e submetem as alterações nos repositórios locais através de branches específicos e solicitações de merge
        Os revisores testam e aprovam as solicitações, reintegrando os branches ao master
        Uma vez revisado, testado e aprovado, o gestor do repositório local submete a alteração para o repositório central e aguarda aprovação dos gestores do projeto.

        Essa disposição traz duas vantagens em relação aos SCVs centralizados: (i) as equipes de locais de desenvolvimento têm total liberdade de organização; (ii) os líderes do projeto possuem total controle sobre o código submetido.
        FIGURA 5.2-1

&nbsp




</body>

</html>